"""
API 3S - Sistema de Rastreamento de Ve√≠culos
==============================================

Bibliotecas utilizadas:
-----------------------
- os: Manipula√ß√£o de vari√°veis de ambiente
- requests: Fazer requisi√ß√µes HTTP (GET, POST)
- json: Manipular dados JSON
- datetime: Trabalhar com datas e hor√°rios
- dotenv (python-dotenv): Carregar e salvar vari√°veis no .env
- time: Controlar delays entre requisi√ß√µes

Instala√ß√£o:
-----------
pip install requests python-dotenv
"""

import os
import requests
import json
import time
from datetime import datetime
from dotenv import load_dotenv, set_key


class API3S:
    def __init__(self):
        load_dotenv()
        self.username = os.getenv('3S_USERNAME')
        self.password = os.getenv('3S_PASSWORD')
        self.token = os.getenv('3S_TOKEN')
        self.base_url = 'https://3stecnologia.eti.br/dataexportapi'
        self.env_file = '.env'
        self.max_chamadas_por_minuto = 9  # Limite seguro (API permite 10)
        self.tempo_espera = 62  # segundos de espera ap√≥s atingir o limite
        self.contador_chamadas = 0

    def validar_login(self):
        """
        Faz login na API e retorna o token de autentica√ß√£o
        Salva automaticamente no .env
        """
        url = f'{self.base_url}/ValidaLogin'
        
        payload = {
            'username': self.username,
            'password': self.password
        }
        
        try:
            response = requests.post(url, json=payload)
            response.raise_for_status()
            
            data = response.json()
            token = (
                data.get('token')
                or data.get('Token')
                or data.get('access_token')
                or data.get('AccessToken')
            )
            
            if token:
                set_key(self.env_file, '3S_TOKEN', token)
                self.token = token
                print(f'‚úÖ Login realizado com sucesso!')
                return token
            else:
                print(f'‚ùå Token n√£o encontrado na resposta')
                return None
                
        except requests.exceptions.RequestException as e:
            print(f'‚ùå Erro ao fazer login: {e}')
            return None
    
    def verificar_token_valido(self):
        """
        Verifica se o token atual ainda √© v√°lido
        """
        if not self.token or self.token == '':
            return False
        
        headers = {'Authorization': f'Bearer {self.token}'}
        
        try:
            response = requests.get(f'{self.base_url}/ListaVeiculos', headers=headers)
            return response.status_code == 200
        except:
            return False
    
    def obter_token(self):
        """
        Obt√©m um token v√°lido (reutiliza existente ou gera novo)
        """
        if self.verificar_token_valido():
            print('‚úÖ Token v√°lido encontrado!')
            return self.token
        
        print('üîÑ Token inv√°lido ou expirado. Gerando novo token...')
        set_key(self.env_file, '3S_TOKEN', '')
        return self.validar_login()
    
    def controlar_rate_limit(self):
        """
        Controla o rate limit da API (9 chamadas por minuto)
        """
        self.contador_chamadas += 1
        
        if self.contador_chamadas >= self.max_chamadas_por_minuto:
            print(f'\n‚è≥ Limite de {self.max_chamadas_por_minuto} chamadas atingido.')
            print(f'‚è≥ Aguardando {self.tempo_espera} segundos...\n')
            time.sleep(self.tempo_espera)
            self.contador_chamadas = 0
    
    def obter_todas_posicoes(self):
        """
        Obt√©m a √∫ltima posi√ß√£o de TODOS os ve√≠culos de uma vez
        Usando id_veiculo = 0 conforme documenta√ß√£o da API
        """
        token = self.obter_token()
        
        if not token:
            print('‚ùå N√£o foi poss√≠vel obter token v√°lido')
            return None
        
        url = f'{self.base_url}/ListaUltimaPosicaoVeiculos/0'
        headers = {'Authorization': f'Bearer {token}'}
        
        print('üìç Buscando posi√ß√µes de TODOS os ve√≠culos...\n')
        
        max_tentativas = 3
        tentativa = 0
        
        while tentativa < max_tentativas:
            try:
                response = requests.get(url, headers=headers)
                response.raise_for_status()
                
                # Incrementa contador de chamadas
                self.controlar_rate_limit()
                
                posicoes = response.json()
                
                # Verifica se retornou erro de rate limit
                if isinstance(posicoes, list) and len(posicoes) > 0:
                    if 'ErroProcessamento' in posicoes[0]:
                        erro = posicoes[0]['ErroProcessamento']
                        
                        if '3S.1040' in erro:  # Excesso de chamadas
                            print(f'‚ö†Ô∏è Rate limit atingido. Aguardando {self.tempo_espera} segundos...')
                            time.sleep(self.tempo_espera)
                            self.contador_chamadas = 0
                            tentativa += 1
                            continue
                        else:
                            print(f'‚ùå Erro ao buscar posi√ß√µes: {erro}')
                            return None
                
                print(f'‚úÖ {len(posicoes)} posi√ß√µes obtidas com sucesso!\n')
                return posicoes
                
            except requests.exceptions.RequestException as e:
                print(f'‚ùå Erro ao obter posi√ß√µes: {e}')
                tentativa += 1
                if tentativa < max_tentativas:
                    print(f'üîÑ Tentativa {tentativa + 1}/{max_tentativas}...')
                    time.sleep(5)
        
        return None
    
    def processar_todas_posicoes(self):
        """
        Fun√ß√£o principal que processa todas as posi√ß√µes dos ve√≠culos
        """
        print('üöÄ Iniciando processamento...\n')
        print('='*60)
        
        # Busca todas as posi√ß√µes de uma vez (id_veiculo = 0)
        posicoes = self.obter_todas_posicoes()
        
        if not posicoes:
            print('‚ùå Nenhuma posi√ß√£o encontrada')
            return None
        
        # Salva o resultado em um arquivo JSON
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        arquivo_saida = f'posicoes_veiculos_{timestamp}.json'
        
        with open(arquivo_saida, 'w', encoding='utf-8') as f:
            json.dump(posicoes, f, ensure_ascii=False, indent=2)
        
        print('='*60)
        print(f'‚úÖ Processamento conclu√≠do!')
        print(f'üìÑ Arquivo gerado: {arquivo_saida}')
        print(f'üìä Total de posi√ß√µes: {len(posicoes)}')
        print('='*60)
        
        return posicoes


if __name__ == '__main__':
    api = API3S()
    api.processar_todas_posicoes()